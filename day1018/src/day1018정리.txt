instance of 연산자
어떠한 객체가 특정 클래스의 자료형인지 판별하기 위한 연산자이다

이클립스에서 클래스이름을 변경하고자 할 때
package explorer에서 바꾸고자 하는 클래스명을 선택하고 마우스 오른쪽 단추
refacter=> rename을 선택한 후 이름을 변경한다
그렇게 하면 파일명, 클래스명도 바뀐다

일반적으로 어떤 클래스의 멤버변수는 필요에 따라 값이 변경될 수 있다
어떤 클래스를 확장하여 새로운 클래스를 만들 수 있다
일반적으로 상속관계에 있을 때 부모 메소드가 자식 클래스에게 맞지 않으면 오버라이딩할 수 있다
하지만 이런 것들을 못하게 막고 싶을때
final키워드를 쓸 수 있다

클래스의 멤버변수의 이름 앞에 final
==> 변수이기는 하지만 정해진 값 이외의 다른값으로 못 바꾸도록 한다==상수
"hello"와 같은 문자열 데이터도 상수이다

클래스의 멤버메소드의 이름 앞에 final
==> 상속관계에 있는 자식클래스들에게 오버라이딩 금지

클래스의 클래스이름 앞에 final
==> 상속금지(확장 금지)

바꾸지도 못하는 final은 굳이 객체마다 따로 메모리를 확보할 필요가 없다
그래서 final맴버는 static으로 만드는 것이 좋다

final변수는 다른 일반 속성과 구별하기 위한 용도로 보통 모두 대문자로 만든다
Math.PI


자바에서는 클래스의 다중상속을 금지해놨다
자바에서는 다중상속의 효과를 기대할 목적으로 인터페이스를 사용한다
class A{}

class B{}

class C extends A,B{} //클래스의 다중상속 금지!!

인터페이스는 클래스 만드는 것처럼 만든다
즉, 인터페이스는 새로운 자료형의 개념이다

class 클래스이름{
}
처럼 클래스를 만들듯이

interface 인터페이스이름{

}

로 인터페이스를 만든다

그러나 인터페이스는 완전추상의 개념으로
인터페이스의 구성요소로 올 수있는것은
상수와 추상메소드만으로 구성되어야 한다

완전추상이기 때문에 인터페이스안에서 변수명 앞에 final 안 붙여도 자동 final이며
메소드 이름 앞에 final를 붙이지 않아도 자동 abstract이다

인터페이스의 자식클래스를 인터페이스를 구현한다고 하며 다음과 같이 사용한다

클래스를 상속할 떄는

class 자식클래스 extends 부모클래스{

}
과 같이 표현하며

인터페이스를 구현하는 클래스는
class 자식클래스 implements 부모인터페이스이름{
}
과 같이 표현한다

class A{

}

interface B{

}

위와 같이 A클래스가 있고 인터페이스 B가 있다고 할 때
A클래스를 상속받고 B인터페이스를 구현하는 클래스는 다음과 같이 표현할 수 있다

class C extends A implements B{

}

인터페이스 구현은 여러 개도 가능하다
class A{}

interface B{}

interface K{}

class C extends A implements B,K{}

클래스의 상속은 하나밖에 되지 않지만
인터페이스 구현은 얼마든지 가능하다
C는 B,K 인터페이스의 모든 메소드들을 오버라이딩해야한다