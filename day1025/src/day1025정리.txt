iterator(반복자)
데이터가 있는 만큼 반복 수행하기 위한 클래스
이 목록의 요소에 대한 반복자를 적절한 순서로 반환

질문) 왜 SistAction의 후손이 되게 해야 합니까?
서비스요청에 따른 일처리 메소드를 하나로 통일시키기 위함이다
그렇지 않으면 만약 각각의 서비스명에 따른 일처리 메소드가 제각각 다르다면 처리하기가 복잡하다

예외처리
==> 프로그램 실행 중에 예기치 않은 상황이 발생하는 것을 "예외"라고 한다
이러한 예외를 처리하는 것을 "예외처리"라고 한다

자바에서는 대부분의 예기치 않은 상황에 대한 클래스가 이미 만들어져 있고
그 예기치 않은 상황이 되면 자동으로 예외 객체를 생성한다

예를 들어 어떤 수를 0으로 나누려고 다음과 같은 문장을 만나면
int a=4/0;
자바가 자동으로 new ArithmeticException()을 생성한다

배열의 인덱스 범위를 넘는 문장을 만나게 되면
int []a= {1,2,3};
int n=a[3];
이라고 하면 
new ArrayIndexOutofBoundException()객체를 자바가 자동으로 생성해준다

throws
==> 만약 어떤 메소드안에서 예외가 발생할 만한 명령어들이 있다고 가정해보자
그러면 메소드 내용도 써야하고 예외처리도 쓰다보면 메소드가 길어진다
그래서 메소드 안에서는 메소드 처리를 위한 핵심내용만 쓰고
예외처리는 메소드를 호출하는 쪽에다가 맡기고 싶다
이럴 때 사용하는 키워드가 "throws"이다
이 말은 예외를 메소드 호출하는 쪽으로 "던진다"라는 말이다

이 키워드는 메소드 이름 뒤에다가 써 준다

RuntimeException
==> 예외와 관련하여 제일 조상 클래스는 Exception클래스이다
Exception클래스의 후손클래스들 중에서
RuntimeException의 후손클래스들은 사용자가 특별히 예외처리를 하지 않아도
자바가 예외처리를 해준다
그러나 RuntimeException의 후손이 아닌 예외들은 반드시 사용자가 예외처리를 해줘야 한다

입출력과 관련한 클래스들을 모아둔 java.io패키지 
또, 네트워크 통신 관련 클래스들을 모아둔 java.net패키지
데이터베이스 연결 관련 클래스들을 모아둔 java.sql패키지의
대부분의 생성자 및 메소드들은 예외를 포함하고 있으며 그것은 모두
RuntimeException의 후손이 아니다

따라서 이것들을 사용하려면 사용자가 반드시 예외처리를 해야 한다

throw
==> 자바는 대부분의 일반적인 예외상황에 대해서는 이미 클래스가 만들어져 있고
그 상황이 되면 자동으로 예외객체가 생성된다
그런데 만약 사용자가 강제로 예외를 발생시켜야 하는 상황이라면
throw를 사용한다
사용하는 방법은 throw new 예외클래스이름();

사용자정의 예외
자바는 대부분의 일반적인 예외상황에 대해서는 이미 예외클래스들이 만들어져 있고
그런 상황이 되면 자동으로 예외객체가 생성된다

그러나 내가 만들고 있는 프로젝트에서만 처리되는
특수한 경우의 상황을 예외로 만들고자 한다면 
(즉, 자바는 모르고 있는 어떠한 상황이 있다면)
사용자가 직접 예외를 만들 수 있다

사용자 정의 예외클래스를 만드는 방법은
예외클래스들의 제일 조상인 Exception를 상속받아 클래스를 만든다
특별히 해줄 건 없고 생성 시에 예외메시지를 전달받아 부모생성자에 전달만 해주면 된다

class 사용자정의예외클래스이름 extends Exception{
public 사용자정의예외클래스이름(String msg){
		super(msg);
	}
}

if(문제상황인지 조건식){
	throw new 사용자정의예외클래스이름(메세지);
}

여태까지 우리는 문제 상황을 if조건식에 물어보고 적절한 메세지를 출력하여 처리했다
이것도 좋은 방법이긴 하지만 우리 프로젝트에서는 미리 이러이러한 상황은 "문제로 인식하자"라는데에
의미가 있다



